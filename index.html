<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MNIST Neural Network Classifier</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            position: relative;
            overflow-x: hidden;
        }

        /* Neural Network Background Animation */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 25% 25%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(118, 75, 162, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(116, 198, 157, 0.1) 0%, transparent 50%);
            z-index: -1;
            animation: neuralBackgroundPulse 12s ease-in-out infinite;
        }

        @keyframes neuralBackgroundPulse {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.4; }
            33% { transform: scale(1.1) rotate(120deg); opacity: 0.6; }
            66% { transform: scale(0.9) rotate(240deg); opacity: 0.5; }
        }

        /* Floating Data Particles */
        .data-particle {
            position: fixed;
            width: 6px;
            height: 6px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 50%;
            z-index: -1;
            animation: dataFlow 20s linear infinite;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
        }

        .data-particle:nth-child(1) { top: 5%; left: 5%; animation-delay: 0s; }
        .data-particle:nth-child(2) { top: 15%; left: 90%; animation-delay: 4s; }
        .data-particle:nth-child(3) { top: 60%; left: 10%; animation-delay: 8s; }
        .data-particle:nth-child(4) { top: 80%; left: 85%; animation-delay: 12s; }
        .data-particle:nth-child(5) { top: 40%; left: 95%; animation-delay: 16s; }

        @keyframes dataFlow {
            0% { transform: translateY(0px) translateX(0px) scale(1); opacity: 0; }
            10% { opacity: 1; }
            50% { transform: translateY(-100px) translateX(-50px) scale(1.2); opacity: 0.8; }
            90% { opacity: 1; }
            100% { transform: translateY(-200px) translateX(-100px) scale(0.5); opacity: 0; }
        }

        /* Enhanced Container */
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            padding: 40px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            animation: containerGlow 8s ease-in-out infinite;
        }

        @keyframes containerGlow {
            0%, 100% { box-shadow: 0 25px 50px rgba(0,0,0,0.15); }
            50% { box-shadow: 0 30px 60px rgba(102, 126, 234, 0.2); }
        }

        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2, #74c6b7, #667eea);
            background-size: 200% 100%;
            animation: borderFlow 4s ease-in-out infinite;
        }

        @keyframes borderFlow {
            0%, 100% { background-position: 0% 0%; }
            50% { background-position: 200% 0%; }
        }

        /* Enhanced Title */
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titlePulse 3s ease-in-out infinite;
            position: relative;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            animation: titleUnderline 2s ease-in-out infinite;
            transform: translateX(-50%);
        }

        @keyframes titleUnderline {
            0%, 100% { width: 0%; }
            50% { width: 60%; }
        }

        /* Enhanced Section */
        .section {
            margin: 30px 0;
            padding: 25px;
            border: 2px solid transparent;
            border-radius: 20px;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(45deg, #667eea, #764ba2) border-box;
            position: relative;
            overflow: hidden;
            animation: sectionFloat 6s ease-in-out infinite;
        }

        @keyframes sectionFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            animation: sectionScan 8s ease-in-out infinite;
        }

        @keyframes sectionScan {
            0%, 100% { left: -100%; }
            50% { left: 100%; }
        }

        .section h3 {
            color: #2d3748;
            margin-top: 0;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            position: relative;
            animation: headerGlow 4s ease-in-out infinite;
        }

        @keyframes headerGlow {
            0%, 100% { text-shadow: none; }
            50% { text-shadow: 0 0 10px rgba(102, 126, 234, 0.3); }
        }

        /* Enhanced File Input */
        .file-input-group {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .file-input-container {
            flex: 1;
            min-width: 200px;
            position: relative;
        }

        input[type="file"] {
            width: 90%;
            padding: 15px;
            border: 2px dashed #667eea;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        input[type="file"]:hover {
            border-color: #764ba2;
            background: #f7fafc;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
        }

        input[type="file"]::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            transition: left 0.5s ease;
        }

        input[type="file"]:hover::before {
            left: 100%;
        }

        /* Enhanced Buttons */
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 10px 5px;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
            ;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            animation: buttonPulse 0.5s ease-in-out;
        }

        @keyframes buttonPulse {
            0%, 100% { transform: translateY(-3px) scale(1); }
            50% { transform: translateY(-3px) scale(1.05); }
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            animation: none;
        }

        /* Enhanced Progress Bar */
        .progress-container {
            background: #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            height: 25px;
            margin: 20px 0;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            animation: progressGlow 2s ease-in-out infinite;
        }

        @keyframes progressGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(102, 126, 234, 0.3); }
            50% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.6); }
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressScan 2s linear infinite;
        }

        @keyframes progressScan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 25px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        /* Enhanced Metrics */
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            animation: metricFloat 4s ease-in-out infinite;
        }

        @keyframes metricFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transform: scaleX(0);
            animation: metricGlow 3s ease-in-out infinite;
        }

        @keyframes metricGlow {
            0%, 100% { transform: scaleX(0); }
            50% { transform: scaleX(1); }
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
        }

        .metric-value {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
            animation: valueCounter 2s ease-out;
        }

        @keyframes valueCounter {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .metric-label {
            font-size: 12px;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        /* Enhanced Predictions Grid */
        .predictions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .prediction-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            animation: cardAppear 0.5s ease-out;
        }

        @keyframes cardAppear {
            0% { transform: scale(0) rotate(5deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .prediction-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.5s ease;
        }

        .prediction-card:hover::before {
            transform: translateX(100%);
        }

        .prediction-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.2);
        }

        .digit-canvas {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .digit-canvas:hover {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .prediction-result {
            font-weight: bold;
            font-size: 16px;
            margin-top: 10px;
        }

        .correct { 
            color: #48bb78; 
            animation: successGlow 2s ease-in-out infinite;
        }

        .incorrect { 
            color: #f56565; 
            animation: errorPulse 1s ease-in-out infinite;
        }

        @keyframes successGlow {
            0%, 100% { text-shadow: none; }
            50% { text-shadow: 0 0 10px rgba(72, 187, 120, 0.5); }
        }

        @keyframes errorPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Enhanced Log */
        .log {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            color: #e2e8f0;
            padding: 20px;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 250px;
            overflow-y: auto;
            margin: 25px 0;
            border: 2px solid #667eea;
            position: relative;
            animation: logGlow 4s ease-in-out infinite;
        }

        @keyframes logGlow {
            0%, 100% { border-color: #667eea; }
            50% { border-color: #764ba2; box-shadow: 0 0 20px rgba(118, 75, 162, 0.3); }
        }

        .log::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            animation: logScan 3s linear infinite;
        }

        @keyframes logScan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Enhanced Status */
        .status {
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            font-weight: 500;
            position: relative;
            overflow: hidden;
            animation: statusSlide 0.5s ease-out;
        }

        @keyframes statusSlide {
            0% { transform: translateX(-20px); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        .status::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: currentColor;
            animation: statusIndicator 2s ease-in-out infinite;
        }

        @keyframes statusIndicator {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.2); }
        }

        .status.info { background: #bee3f8; color: #2b6cb0; }
        .status.success { background: #c6f6d5; color: #2f855a; }
        .status.error { background: #fed7d7; color: #c53030; }
        .status.warning { background: #fefcbf; color: #b7791f; }

        /* Enhanced Model Parameters */
        .model-params {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .param-group {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            animation: paramFloat 5s ease-in-out infinite;
        }

        @keyframes paramFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }

        .param-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .param-group:hover::before {
            transform: scaleX(1);
        }

        .param-group:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
        }

        .param-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        .param-group input, .param-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .param-group input:focus, .param-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.2);
            transform: scale(1.02);
        }

        /* Training Animation */
        .training-active {
            animation: trainingPulse 2s ease-in-out infinite;
        }

        @keyframes trainingPulse {
            0%, 100% { background: rgba(255, 255, 255, 0.95); }
            50% { background: rgba(102, 126, 234, 0.1); }
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .file-input-group {
                flex-direction: column;
            }
            
            .metrics {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 15px;
            }
            
            .model-params {
                grid-template-columns: 1fr;
            }
            
            .predictions-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Data Flow Background Particles -->
    <div class="data-particle"></div>
    <div class="data-particle"></div>
    <div class="data-particle"></div>
    <div class="data-particle"></div>
    <div class="data-particle"></div>

    <div class="container">
        <h1>üß† MNIST Neural Network Classifier</h1>
        
        <div class="section">
            <h3>üìÅ Data Loading</h3>
            <p>Upload your MNIST CSV files. Training CSV should have labels in first column, test CSV format will be auto-detected.</p>
            <div class="file-input-group">
                <div class="file-input-container">
                    <label>Training Data (CSV):</label>
                    <input type="file" id="trainFile" accept=".csv" />
                </div>
                <div class="file-input-container">
                    <label>Test Data (CSV):</label>
                    <input type="file" id="testFile" accept=".csv" />
                </div>
            </div>
            <button onclick="loadData()">Load Data</button>
            <div id="dataStatus"></div>
        </div>
        
        <div class="section">
            <h3>‚öôÔ∏è Model Configuration</h3>
            <div class="model-params">
                <div class="param-group">
                    <label for="hiddenUnits">Hidden Units:</label>
                    <input type="number" id="hiddenUnits" value="128" min="32" max="512">
                </div>
                <div class="param-group">
                    <label for="learningRate">Learning Rate:</label>
                    <input type="number" id="learningRate" value="0.005" step="0.001" min="0.0001" max="0.1">
                </div>
                <div class="param-group">
                    <label for="epochs">Epochs:</label>
                    <input type="number" id="epochs" value="30" min="1" max="100">
                </div>
                <div class="param-group">
                    <label for="batchSize">Batch Size:</label>
                    <select id="batchSize">
                        <option value="32">32</option>
                        <option value="64">64</option>
                        <option value="128" selected>128</option>
                        <option value="256">256</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="section" id="trainingSection">
            <h3>üéØ Training</h3>
            <button onclick="createAndTrainModel()" id="trainBtn" disabled>Create & Train Model</button>
            <button onclick="stopTraining()" id="stopBtn" disabled>Stop Training</button>
            
            <div class="progress-container" style="display: none;" id="progressContainer">
                <div class="progress-bar" id="progressBar">
                    <div class="progress-text" id="progressText">0%</div>
                </div>
            </div>
            
            <div class="metrics" id="metricsContainer" style="display: none;">
                <div class="metric-card">
                    <div class="metric-value" id="currentEpoch">0</div>
                    <div class="metric-label">Current Epoch</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="trainLoss">0.00</div>
                    <div class="metric-label">Training Loss</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="trainAccuracy">0.00%</div>
                    <div class="metric-label">Training Accuracy</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="valAccuracy">0.00%</div>
                    <div class="metric-label">Validation Accuracy</div>
                </div>
            </div>
            
            <div class="log" id="trainingLog"></div>
        </div>
        
        <div class="section">
            <h3>üìä Testing & Results</h3>
            <button onclick="evaluateModel()" id="testBtn" disabled>Test Model</button>
            <button onclick="showRandomPredictions()" id="predBtn" disabled>Show Random Predictions</button>
            
            <div id="testResults"></div>
            <div class="predictions-grid" id="predictionsContainer"></div>
        </div>

        <button onclick="window.location.href='handwritten.html'">Go to Handwritten Digit Recognition</button>
    </div>

    <script>
        let trainData = null;
        let testData = null;
        let model = null;
        let isTraining = false;
        let trainingHistory = [];

        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('dataStatus');
            statusEl.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function log(message) {
            const logEl = document.getElementById('trainingLog');
            const timestamp = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${timestamp}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        async function parseCSV(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    complete: (results) => {
                        resolve(results.data);
                    },
                    error: (error) => reject(error),
                    skipEmptyLines: true
                });
            });
        }

        function preprocessData(data, hasLabels = true) {
            const processedData = {
                images: [],
                labels: []
            };

            log(`Processing ${data.length} rows of data...`);

            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                if (row.length === 0) continue;

                let pixels, label;
                
                if (hasLabels) {
                    const labelValue = parseFloat(row[0]);
                    label = Math.round(labelValue);
                    // Ensure we have valid label (0-9)
                    if (isNaN(label) || label < 0 || label > 9) {
                        log(`Skipping row ${i}: invalid label ${row[0]}`);
                        continue;
                    }
                    pixels = row.slice(1).map(pixel => {
                        const val = parseFloat(pixel);
                        return isNaN(val) ? 0.0 : Math.max(0.0, Math.min(1.0, val / 255.0));
                    });
                } else {
                    label = null;
                    pixels = row.map(pixel => {
                        const val = parseFloat(pixel);
                        return isNaN(val) ? 0.0 : Math.max(0.0, Math.min(1.0, val / 255.0));
                    });
                }

                if (pixels.length === 784) { // 28x28 = 784
                    processedData.images.push(pixels);
                    if (hasLabels) {
                        processedData.labels.push(label);
                    }
                } else {
                    log(`Skipping row ${i}: expected 784 pixels, got ${pixels.length}`);
                }
            }

            log(`Successfully processed ${processedData.images.length} samples`);
            if (hasLabels) {
                const labelCounts = {};
                processedData.labels.forEach(label => {
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                });
                log(`Label distribution: ${JSON.stringify(labelCounts)}`);
            }

            return processedData;
        }

        async function loadData() {
            const trainFile = document.getElementById('trainFile').files[0];
            const testFile = document.getElementById('testFile').files[0];

            if (!trainFile || !testFile) {
                showStatus('Please select both training and test CSV files.', 'error');
                return;
            }

            showStatus('Loading and parsing CSV files...', 'info');

            try {
                // Parse training data
                const trainCsv = await parseCSV(trainFile);
                trainData = preprocessData(trainCsv, true);

                // Parse test data - try to detect if it has labels
                const testCsv = await parseCSV(testFile);
                const hasLabels = testCsv.length > 0 && testCsv[0].length === 785; // 1 label + 784 pixels
                testData = preprocessData(testCsv, hasLabels);

                showStatus(
                    `‚úÖ Data loaded successfully!\n` +
                    `Training samples: ${trainData.images.length}\n` +
                    `Test samples: ${testData.images.length}\n` +
                    `Test labels available: ${hasLabels ? 'Yes' : 'No'}`,
                    'success'
                );

                document.getElementById('trainBtn').disabled = false;
                log(`Loaded ${trainData.images.length} training samples and ${testData.images.length} test samples`);

            } catch (error) {
                showStatus(`Error loading data: ${error.message}`, 'error');
                log(`Error: ${error.message}`);
            }
        }

        function createModel() {
            const hiddenUnits = parseInt(document.getElementById('hiddenUnits').value);
            const learningRate = parseFloat(document.getElementById('learningRate').value);

            model = tf.sequential();

            // Input Layer
            model.add(tf.layers.dense({
                inputShape: [784],
                units: hiddenUnits,
                activation: 'relu',
                kernelInitializer: 'heNormal'
            }));

            // Dropout
            model.add(tf.layers.dropout({ rate: 0.2 }));

            // Second Hidden Layer
            model.add(tf.layers.dense({
                units: hiddenUnits / 2,
                activation: 'relu',
                kernelInitializer: 'heNormal'
            }));

            // Dropout again
            model.add(tf.layers.dropout({ rate: 0.2 }));

            // Output Layer
            model.add(tf.layers.dense({
                units: 10,
                activation: 'softmax',
                kernelInitializer: 'glorotUniform'
            }));

            model.compile({
                optimizer: tf.train.adam(learningRate),
                loss: 'categoricalCrossentropy',
                metrics: [tf.metrics.categoricalAccuracy]
            });

            log(`‚úÖ Model built with ${hiddenUnits} hidden units`);
            return model;
        }

        async function createAndTrainModel() {
            if (!trainData) {
                showStatus('Please load training data first.', 'error');
                return;
            }

            isTraining = true;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('metricsContainer').style.display = 'block';
            document.getElementById('trainingSection').classList.add('training-active');

            try {
                // Create model
                createModel();

                // Prepare data
                const epochs = parseInt(document.getElementById('epochs').value);
                const batchSize = parseInt(document.getElementById('batchSize').value);

                // Validate label data
                if (!Array.isArray(trainData.labels) || trainData.labels.some(l => typeof l !== 'number' || isNaN(l) || l < 0 || l > 9)) {
                    throw new Error('Invalid training labels. Make sure labels are numbers between 0 and 9.');
                }

                // Split training and validation sets
                const splitIdx = Math.floor(trainData.images.length * 0.8);
                const trainImages = trainData.images.slice(0, splitIdx);
                const trainLabels = trainData.labels.slice(0, splitIdx);
                const valImages = trainData.images.slice(splitIdx);
                const valLabels = trainData.labels.slice(splitIdx);

                const trainXs = tf.tensor2d(trainImages, [trainImages.length, 784], 'float32');
                const valXs = tf.tensor2d(valImages, [valImages.length, 784], 'float32');

                function createOneHot(labels) {
                    return labels.map(label => {
                        const vector = new Array(10).fill(0);
                        if (typeof label === 'number' && label >= 0 && label <= 9) {
                            vector[label] = 1;
                        }
                        return vector;
                    });
                }

                const trainOneHot = createOneHot(trainLabels);
                const valOneHot = createOneHot(valLabels);

                // Debug log
                log(`Train one-hot example: ${trainOneHot[0].join(', ')}`);
                log(`Train labels count: ${trainOneHot.length}`);
                log(`Validation one-hot example: ${valOneHot[0].join(', ')}`);
                log(`Validation labels count: ${valOneHot.length}`);

                // Ensure all vectors are valid
                if (!trainOneHot.every(row => Array.isArray(row) && row.length === 10 && row.some(v => v === 1))) {
                    throw new Error("Invalid one-hot label detected in training data.");
                }

                const trainYs = tf.tensor2d(trainOneHot, [trainOneHot.length, 10], 'float32');
                const valYs = tf.tensor2d(valOneHot, [valOneHot.length, 10], 'float32');

                log(`Starting training for ${epochs} epochs with batch size ${batchSize}`);

                await model.fit(trainXs, trainYs, {
                    epochs,
                    batchSize,
                    validationData: [valXs, valYs],
                    shuffle: true,
                    verbose: 0,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (!isTraining) return true;

                            const progress = ((epoch + 1) / epochs) * 100;
                            document.getElementById('progressBar').style.width = `${progress}%`;
                            document.getElementById('progressText').textContent = `${Math.round(progress)}%`;

                            const acc = logs.categoricalAccuracy ?? 0;
                            const valAcc = logs.val_categoricalAccuracy ?? 0;

                            document.getElementById('currentEpoch').textContent = epoch + 1;
                            document.getElementById('trainLoss').textContent = logs.loss.toFixed(4);
                            document.getElementById('trainAccuracy').textContent = (acc * 100).toFixed(2) + '%';
                            document.getElementById('valAccuracy').textContent = (valAcc * 100).toFixed(2) + '%';

                            trainingHistory.push(logs);
                            log(`Epoch ${epoch + 1}/${epochs} - Loss: ${logs.loss.toFixed(4)}, Accuracy: ${(acc * 100).toFixed(2)}%, Val Accuracy: ${(valAcc * 100).toFixed(2)}%`);
                        }
                    }
                });

                // Cleanup
                trainXs.dispose();
                trainYs.dispose();
                valXs.dispose();
                valYs.dispose();

                if (isTraining) {
                    showStatus('‚úÖ Training completed successfully!', 'success');
                    log('Training completed successfully!');
                    document.getElementById('testBtn').disabled = false;
                    document.getElementById('predBtn').disabled = false;
                } else {
                    showStatus('‚èπÔ∏è Training stopped by user.', 'warning');
                    log('Training stopped by user.');
                }

            } catch (error) {
                showStatus(`Training error: ${error.message}`, 'error');
                log(`Training error: ${error.message}`);
                console.error(error);
            } finally {
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('trainingSection').classList.remove('training-active');
                if (document.getElementById('progressBar').style.width !== '100%') {
                    document.getElementById('progressContainer').style.display = 'none';
                }
            }
        }

        function stopTraining() {
            isTraining = false;
            log('Stopping training...');
        }

        async function evaluateModel() {
            if (!model || !testData) {
                showStatus('Please train a model and load test data first.', 'error');
                return;
            }

            try {
                const testXs = tf.tensor2d(testData.images, [testData.images.length, 784], 'float32');
                
                if (testData.labels && testData.labels.length > 0) {
                    // Manually create one-hot encoded test labels
                    function createOneHot(labels) {
                        return labels.map(label => {
                            const vector = new Array(10).fill(0);
                            const safeLabel = Math.min(Math.max(parseInt(label), 0), 9); // force between 0-9
                            vector[safeLabel] = 1;
                            return vector;
                        });
                    }
                    
                    const testOneHot = createOneHot(testData.labels);
                    const testYs = tf.tensor2d(testOneHot, [testOneHot.length, 10], 'float32');
                    
                    const evaluation = await model.evaluate(testXs, testYs);
                    
                    const testLoss = await evaluation[0].data();
                    const testAccuracy = await evaluation[1].data();
                    
                    document.getElementById('testResults').innerHTML = `
                        <div class="metrics">
                            <div class="metric-card">
                                <div class="metric-value">${testLoss[0].toFixed(4)}</div>
                                <div class="metric-label">Test Loss</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${(testAccuracy[0] * 100).toFixed(2)}%</div>
                                <div class="metric-label">Test Accuracy</div>
                            </div>
                        </div>
                    `;
                    
                    log(`Test Results - Loss: ${testLoss[0].toFixed(4)}, Accuracy: ${(testAccuracy[0] * 100).toFixed(2)}%`);
                    evaluation[0].dispose();
                    evaluation[1].dispose();
                    testYs.dispose();
                } else {
                    // No test labels, just show that we can make predictions
                    const predictions = await model.predict(testXs).data();
                    document.getElementById('testResults').innerHTML = `
                        <div class="status success">
                            ‚úÖ Model successfully made predictions on ${testData.images.length} test samples!
                            (No labels available for accuracy calculation)
                        </div>
                    `;
                    log(`Made predictions on ${testData.images.length} test samples (no labels for accuracy calculation)`);
                }
                
                testXs.dispose();
                
            } catch (error) {
                showStatus(`Evaluation error: ${error.message}`, 'error');
                log(`Evaluation error: ${error.message}`);
                console.error('Full evaluation error:', error);
            }
        }

        function drawDigit(canvas, pixels) {
            const ctx = canvas.getContext('2d');
            canvas.width = 84;
            canvas.height = 84;
            
            // Clear canvas with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 84, 84);
            
            // Try direct pixel-by-pixel drawing approach
            for (let y = 0; y < 28; y++) {
                for (let x = 0; x < 28; x++) {
                    const pixelIndex = y * 28 + x;
                    let pixelValue = pixels[pixelIndex];
                    
                    // Handle different possible data formats
                    if (pixelValue > 1) {
                        // Data might be in 0-255 range already
                        pixelValue = pixelValue / 255;
                    }
                    
                    // Convert to grayscale (0 = black, 1 = white for MNIST)
                    const grayValue = Math.floor(pixelValue * 255);
                    
                    // Set pixel color
                    ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                    
                    // Draw 3x3 pixel blocks to scale up from 28x28 to 84x84
                    ctx.fillRect(x * 3, y * 3, 3, 3);
                }
            }
            
            // Add border
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, 84, 84);
        }

        async function showRandomPredictions() {
            if (!model || !testData) {
                showStatus('Please train a model and load test data first.', 'error');
                return;
            }

            const container = document.getElementById('predictionsContainer');
            container.innerHTML = '';

            // Show 12 random predictions
            const numPredictions = Math.min(12, testData.images.length);
            const indices = [];
            while (indices.length < numPredictions) {
                const idx = Math.floor(Math.random() * testData.images.length);
                if (!indices.includes(idx)) indices.push(idx);
            }

            try {
                for (const idx of indices) {
                    const pixels = testData.images[idx];
                    const inputTensor = tf.tensor2d([pixels], [1, 784], 'float32');
                    const prediction = await model.predict(inputTensor).data();
                    const predictedClass = prediction.indexOf(Math.max(...prediction));

                    const card = document.createElement('div');
                    card.className = 'prediction-card';

                    const canvas = document.createElement('canvas');
                    canvas.className = 'digit-canvas';
                    drawDigit(canvas, pixels); // Actually draw the digit

                    // Append canvas directly (preserves drawing)
                    card.appendChild(canvas);

                    const actualLabel = testData.labels && testData.labels[idx] !== undefined ? testData.labels[idx] : '?';
                    const isCorrect = actualLabel !== '?' && actualLabel === predictedClass;
                    const resultClass = actualLabel !== '?' ? (isCorrect ? 'correct' : 'incorrect') : '';

                    const resultDiv = document.createElement('div');
                    resultDiv.className = `prediction-result ${resultClass}`;
                    resultDiv.innerHTML = `
                        Predicted: ${predictedClass}<br>
                        ${actualLabel !== '?' ? `Actual: ${actualLabel}` : 'No label'}
                        ${actualLabel !== '?' ? `<br>${isCorrect ? '‚úì' : '‚úó'}` : ''}
                    `;
                    card.appendChild(resultDiv);

                    const confidenceDiv = document.createElement('div');
                    confidenceDiv.style.cssText = 'font-size: 12px; color: #718096; margin-top: 5px;';
                    confidenceDiv.textContent = `Confidence: ${(Math.max(...prediction) * 100).toFixed(1)}%`;
                    card.appendChild(confidenceDiv);

                    container.appendChild(card);
                    inputTensor.dispose();
                }

                log(`Displayed ${numPredictions} random predictions`);

            } catch (error) {
                showStatus(`Prediction error: ${error.message}`, 'error');
                log(`Prediction error: ${error.message}`);
            }
        }

        // Initialize
        log('MNIST Neural Network Classifier initialized');
        log('Please upload your training and test CSV files to get started');
    </script>
</body>
</html>